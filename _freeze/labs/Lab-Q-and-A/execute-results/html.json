{
  "hash": "41721a4126af3ca2437d3b690710a112",
  "result": {
    "markdown": "---\ntitle: \"Q and A\"\nimage: \"Lab-Q-and-A-resources/preview.png\"\nauthor: \"Jonathan Jayes\"\ndate: 2023-02-28\nexecute: \n  warning: false\n  message: false\n  echo: true\nformat:\n  # pdf:\n  #   toc: true\n  #   colorlinks: true\n  html:\n    code-overflow: wrap\n---\n\n::: {.cell}\n\n:::\n\n\n## Purpose\n\nIn the article below I share the help that I provided to students who asked about manual colour palettes in Stata and how to calculate Moran's I in Stata, a measure of spatial autocorrelation.\n\n## Choose specific colours for choropleth\n\nQ: Could you help me with the code and command I need to use in Stata to change the color of a specific region in a choropleth map?\n\nA: Sure! We can choose our own colours for a palette with their RGB codes\n\n::: {.callout-tip}\n### RGB colour codes\n\nWhat are RGB Color Codes?\n\nRGB color codes are a set of numerical values used to specify colors in digital devices such as computers, televisions, and smartphones. RGB stands for red, green, and blue, which are the primary colors used in digital displays. Each color is represented by a value between 0 and 255, with 0 indicating no intensity and 255 indicating maximum intensity.\n\nUsing RGB Color Codes\n\nRGB color codes are commonly used to specify different types of colors, including those used in web design, graphic design, and data visualization. For example, the color \"midnightblue\" can be represented by the hex code 191970 or the RGB values (25, 25, 112). In this case, the first two digits of the hex code represent the intensity of red, the second two digits represent green, and the last two digits represent blue. Similarly, the RGB values represent the intensity of red, green, and blue, respectively.\n\nIn data visualization, RGB color codes are often used to create choropleth maps that display different colors based on the value of a particular variable in a specific region. By using RGB color codes, users can create maps that are visually appealing and easy to interpret.\n:::\n\nFirst you can choose your colours by Googling a colour that you like and copying across it's rgb code:\n\n![Google colours](Lab-Q-and-A-resources/google-colours.png){width=100%}\n\nIn this case we want three colours for three different groups. Let's choose some from the [Okabe-Ito palette](https://www.reed.edu/economics/parker/311/Creating-Color-Blind-Accessible-Figures-ProfHacker---Blogs---The-Chronicle-of-Higher-Education.pdf).\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Okabe-Ito colours](Lab-Q-and-A_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nNext in Stata we import the data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set up\nclear all\nset more off\n\nuse regional_dataset, clear\n```\n:::\n\n\nNow we create some groups\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# manual legends\n\nkeep if country == \"France\"\n\n# set groups\n\ngen groups = .\n\nreplace groups = 1 if region == \"Alsace\" |  region == \"Champagne-Ardenne\" | ///\n\tregion == \"Bretagne\" | ///\n\tregion == \"Franche-Comté\" | region == \"Languedoc-Roussillon\" | ///\n\tregion == \"Lorraine\" | region == \"Midi-Pyrénées\" | region == \"Nord - Pas-de-Calais\" | ///\n\tregion == \"Provence-Alpes-Côte d'Azur\" | region == \"Corse\" | region == \"Picardie\"\n\nreplace groups = 2 if region == \"Aquitaine\" | region == \"Auvergne\" | region == \"Basse-Normandie\" | ///\n\tregion == \"Bourgogne\" | ///\n\tregion == \"Centre\" | region == \"Centre\" | region == \"Centre\" | region == \"Centre\" | ///\n\tregion == \"Haute-Normandie\" | region == \"Limousin\" | region == \"Pays de la Loire\" | ///\n\tregion == \"Poitou-Charentes\" | region == \"Rhône-Alpes\"\n\nreplace groups = 3 if region == \"Île de France\"\n```\n:::\n\n\nNow we can map the data, putting our RGB colour codes into the `fcolor` command: `fcolor(\"230 159 0\" \"86 180 233\" \"0 158 115\")`. In addition, we label our groups in the legend and set appropriate breaks with the `clbreaks` command.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Orange: \"230 159 0\"\n# Blue: \"86 180 233\"\n# Green: \"0 158 115\"\n\n\n # Put the rgb values for the colours into the `fcolor` command, and then put the labels into the legend.\nspmap groups using \"nutscoord.dta\" if year == 1950, id(_ID) fcolor(\"230 159 0\" \"86 180 233\" \"0 158 115\") legend(pos(9)) legstyle(2) ///\n\ttitle(\"Regional GDP per Capita - 1950\", size(medium)) ///\n\tosize(0.02 ..) ocolor(white ..) /// \n\tclmethod(custom) clbreaks(0 1 2 3) ///\n\tlegend(order(2 \"MLP\" 3 \"EM\" 4 \"JLM\"))\n```\n:::\n\n\nThis is what the map looks like:\n\n![Map of France with regions](Lab-Q-and-A-resources/France.png){width=100%}\n\n## Moran's I\n\nQ: How do I calculate Moran's I in Stata? \n\nA: We need to calculate the spatial weighting matrix, and then calculate Moran's I.\n\n::: {.callout-tip}\n### Moran's I\n\n[Moran’s I](https://stats.oarc.ucla.edu/stata/faq/how-can-i-calculate-morans-i-in-stata/#:~:text=Moran's%20I%20is%20a%20measure,calculate%20Moran's%20I%20in%20Stata.) is a measure of spatial autocorrelation–how related the values of a variable are based on the locations where they were measured. In other words, [global spatial autocorrelation](http://fmwww.bc.edu/RePEc/bocode/m/moransi.pdf) measures the extent to which regions are interdependent.\n:::\n\nTo calculate Moran's I, first we need to calculate the spatial weighting matrix. This matrix shows us how far each region is away from every other region. To calculate this matrix, we need to find the midpoint of each region. There are multiple ways to do this, but we will go with the simplest, which is to take the mean of all of the coordinates that make up the polygon.\n\nWe install the user written command that allows us to calculate the spatial weighting matrix `sg162`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclear all\nset more off\n\n # Install required user written command\nssc install sg162\n```\n:::\n\n\nNext we find the mean x and y coordinates of each region and join this to our data from the **regional_dataset**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuse nutscoord, clear \nbysort _ID: egen mean_x = mean(_X)\nbysort _ID: egen mean_y = mean(_Y)\nkeep _ID mean_x mean_y\nduplicates drop\nmerge 1:m _ID using regional_dataset\nkeep if _merge == 3\ndrop _merge\n```\n:::\n\n\nNext we choose a year to calculate Moran's I for:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkeep if year == 2000\n```\n:::\n\n\nAnd calculate the **spat**ial **w**eighting **mat**rix with the **spatwmat** command.\n\nThe band option allows us to drop any outliers which are too far away to be considered neighbours. We include all regions by setting the band's upper bound very high.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspatwmat, name(nutsweights) xcoord(mean_x) ycoord(mean_y) band(0 1.2e+06 )\n```\n:::\n\n\nThe output that we get looks like this:\n\n![Spatial weighting matrix output](Lab-Q-and-A-resources/moran-i-1.png){width=100%}\n\nTo calculate Moran's I for 2010 with regional GDP per capita, we use the weights we have calculated and the following command:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspatgsa regional_gdp_cap_1990, weights(nutsweights) moran\n```\n:::\n\n\nThe output looks like this:\n\n![Moran's I calculation output](Lab-Q-and-A-resources/moran-i-2.png){width=100%}\n\n\nBased on these results, we can reject the null hypothesis that there is zero spatial autocorrelation present in the variable regional_gdp_cap_1990 at alpha = .05. In other words, regional GDP per capita is related to geography in 2010.\n",
    "supporting": [
      "Lab-Q-and-A_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}